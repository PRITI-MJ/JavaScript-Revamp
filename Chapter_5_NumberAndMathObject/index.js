//Number
let a = 10;
console.log(a);
let b = 345.6821;
let c = b.toFixed(1);
console.log(c); //345.7 (toFixed has done the round off of that number till dec)
console.log(typeof c); //string
console.log(b); //345.6821 (it is not changing because in JS, primitive data types are immutable)


console.log(b.toPrecision(5)); //345.68 (it is rounding off the number till 5 digits)
console.log(typeof b.toPrecision(5)); //string

console.log(b.toString()); //345.6821 (number is converted into string)


//creating number in the form of object
let x = new Number(10);// creating number in the form of object
console.log(x); //[Number: 10]
console.log(typeof x); //object
let y = 20; //crating number in the form of primitive data type


let num1 = new Number(20);
let num2 = new Number(20);
console.log(num1 == num2); //false (because both are different objects in the memory)

let obj1 = {
    name: "Rohit"
}
let obj2 = {
    name: "Rohit"
}
console.log(obj1 == obj2); //false (because both are different objects in the memory)
let obj3 = obj1;
console.log(obj1 == obj3); //true (because both are pointing to the same object in the memory) => Pass by reference

let m = 10;
let n = m;
console.log(m == n); //true (because both are primitive data types and have same value) => Pass by value   
//but they are pointing to different memory locations



//MATH
console.log(Math.abs(-4)); //4
console.log(Math.PI); //3.141592653589793
console.log(Math.LN10); //2.302585092994046
console.log(Math.SQRT2); //1.4142135623730951
console.log(Math.ceil(6.3)); //7 (rounding off to the next integer)
console.log(Math.ceil(-6.3)); //-6 (rounding off to the next integer)
console.log(Math.floor(6.3)); //6 (rounding off to the previous integer)
console.log(Math.floor(-6.3)); //-7 (rounding off to the previous integer)
console.log(Math.log10(20)); //1.3010299956639813 (logarithm to the base 10)
console.log(Math.max(2, 5, 1, 8, 6)); //8

console.log(Math.random()); //0.0 to 0.999999 (any random number between 0 and 1)
//[0, 1) : It will generate between 0 and 1, where 0 is included but 1 is not included




// Game of Random Numbers

console.log(Math.floor(Math.random() * 10)); //0 to 9 (any random number between 0 and 9)
//[0, 10) : It will generate between 0 and 10, where 0 is included but 10 is not included


console.log(Math.floor(Math.random() * 10)+1); //1 to 10 (any random number between 1 and 10)
//[1, 10] : It will generate between 1 and 10, where both 1 and 10 are included


//Generating Number from 1-6
console.log(Math.floor(Math.random() * 6) + 1); //1 to 6 (any random number between 1 and 6)
//[1, 6] : It will generate between 1 and 6, where both 1 and 6 are included

//General Formula
//Math.floor(math.random() * totalNumberOfOutcome) + shift
//Math.floor(math.random() * (max - min + 1)) + min

//genrating number between 15 to 25
console.log(Math.floor(Math.random() * 11) + 15); //15 to 25 (any random number between 15 and 25)
//[15, 25] : It will generate between 15 and 25, where both 15 and 25 are included
//totalNumberOfOutcome = 25 - 15 + 1 = 11
//shift = 15    


//OTP Generate: 4 digit: 1000-9999
console.log(Math.floor(Math.random()*(9999-1000+1))+1000); //1000 to 9999 (any random number between 1000 and 9999)
//[1000, 9999] : It will generate between 1000 and 9999, where both 1000 and 9999 are included
//totalNumberOfOutcome = 9999 - 1000 + 1 = 9000
//shift = 1000  


//Why this method can't be used as a secure OTP Generate method?
//Ans: Because Math.random() is not a cryptographically secure random number generator. 
//It means that the sequence of numbers generated by Math.random() can be predicted if the initial seed value is known. 
//This makes it vulnerable to attacks where an attacker can guess the OTP by predicting the sequence of numbers generated by Math.random(). 
//For secure OTP generation, it is recommended to use a cryptographically secure random number generator like window.crypto.getRandomValues() in browsers or crypto.randomBytes() in Node.js.


